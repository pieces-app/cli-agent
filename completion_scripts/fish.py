from base import (
    CompletionGenerator,
    CommandInfo,
    OptionInfo,
    PositionalInfo,
    BaseCommand,
)
from pieces import __version__


class FishCompletionGenerator(CompletionGenerator):
    """Generates Fish completion scripts."""

    def generate(self) -> str:
        """Generate the Fish completion script."""
        script = self._generate_header()
        script += self._generate_helper_functions()
        script += self._generate_global_options()
        script += self._generate_commands()
        script += self._generate_command_options()
        script += self._generate_command_groups()
        return script.strip()

    def _generate_header(self) -> str:
        """Generate the script header."""
        return f"""# Fish completion for {self.tool_name}
# This file is automatically generated by the Pieces CLI.
# Do not edit this file manually.
# Version: {__version__}

# Disable file completions by default
complete -c {self.tool_name} -f
"""

    def _generate_helper_functions(self) -> str:
        """Generate Fish helper functions."""
        return f"""
# Helper function to check if we're completing the first argument (command)
function __{self.tool_name}_needs_command
    set -l cmd (commandline -opc)
    set -e cmd[1]  # Remove the program name
    for arg in $cmd
        # If we find a non-option argument, we have a command
        if not string match -q -- '-*' $arg
            return 1
        end
    end
    return 0
end

# Helper function to get the current command
function __{self.tool_name}_get_command
    set -l cmd (commandline -opc)
    set -e cmd[1]  # Remove the program name
    for arg in $cmd
        if not string match -q -- '-*' $arg
            echo $arg
            return 0
        end
    end
    return 1
end

# Helper function to check if we're in a specific command
function __{self.tool_name}_using_command
    set -l cmd (__{self.tool_name}_get_command)
    test "$cmd" = "$argv[1]"
end

# Helper function to check if we need a subcommand for a command group
function __{self.tool_name}_needs_subcommand
    set -l cmd (commandline -opc)
    set -e cmd[1]  # Remove the program name
    set -l command_found 0
    set -l subcommand_found 0

    for arg in $cmd
        if not string match -q -- '-*' $arg
            if test $command_found -eq 0
                # This is the main command
                if test "$arg" = "$argv[1]"
                    set command_found 1
                else
                    return 1  # Different command
                end
            else
                # This is a subcommand
                set subcommand_found 1
                return 1
            end
        end
    end

    # We found the command but no subcommand yet
    test $command_found -eq 1 -a $subcommand_found -eq 0
end

# Helper function to get the subcommand
function __{self.tool_name}_get_subcommand
    set -l cmd (commandline -opc)
    set -e cmd[1]  # Remove the program name
    set -l command_found 0

    for arg in $cmd
        if not string match -q -- '-*' $arg
            if test $command_found -eq 0
                set command_found 1
            else
                # This is the subcommand
                echo $arg
                return 0
            end
        end
    end
    return 1
end

# Helper function to check if we're using a specific subcommand
function __{self.tool_name}_using_subcommand
    set -l main_cmd (__{self.tool_name}_get_command)
    set -l sub_cmd (__{self.tool_name}_get_subcommand)
    test "$main_cmd" = "$argv[1]" -a "$sub_cmd" = "$argv[2]"
end

# Helper function to check if the last argument is a specific flag
function __{self.tool_name}_last_arg_is
    set -l cmd (commandline -opc)
    set -l last_arg $cmd[-1]
    test "$last_arg" = "$argv[1]"
end

# Helper function to check if we should complete option values
function __{self.tool_name}_should_complete_option_value
    set -l flag $argv[1]
    set -l cmd_condition $argv[2]
    
    # Check if the command condition is met
    if not eval $cmd_condition
        return 1
    end
    
    # Check if the last token is exactly the flag (with space after it)
    # This prevents showing values when typing -i without space
    set -l line (commandline -c)
    set -l last_char (string sub -s -1 "$line")
    
    # Only show completions if there's a space after the flag
    if test "$last_char" = " "
        # Check if the previous token is our flag
        if __{self.tool_name}_last_arg_is "$flag"
            return 0
        end
    end
    
    return 1
end
"""

    def _generate_global_options(self) -> str:
        """Generate global options."""
        return f"""
# Global options - only available before any command is specified
complete -c {self.tool_name} -n "__{self.tool_name}_needs_command" -s h -l help -d "Show help message"
complete -c {self.tool_name} -n "__{self.tool_name}_needs_command" -s v -l version -d "Show version"
complete -c {self.tool_name} -n "__{self.tool_name}_needs_command" -l ignore-onboarding -d "Ignore onboarding for this command"
"""

    def _generate_commands(self) -> str:
        """Generate command completions."""
        script = """
# Commands - only show when no command is specified yet
"""

        # Add main commands
        for cmd_name, cmd_info in sorted(self.parser.commands_info.items()):
            description = cmd_info.help.replace("'", "\\'")
            script += f"""complete -c {self.tool_name} -n "__{self.tool_name}_needs_command" -a "{cmd_name}" -d "{description}"
"""

        # Add aliases
        for alias, main_cmd in sorted(self.parser.aliases_map.items()):
            description = f"Alias for {main_cmd}"
            script += f"""complete -c {self.tool_name} -n "__{self.tool_name}_needs_command" -a "{alias}" -d "{description}"
"""

        return script

    def _generate_command_options(self) -> str:
        """Generate command-specific options."""
        script = """
# Command-specific completions
"""

        for cmd_name, cmd_info in self.parser.commands_info.items():
            script += self._generate_command_completion(cmd_name, cmd_info)

        return script

    def _generate_command_completion(self, cmd_name: str, cmd_info: CommandInfo) -> str:
        """Generate completion for a specific command."""
        script = ""
        cmd_details = self.parser.subcommand_details.get(cmd_name, {})
        options = cmd_details.get("options", [])
        positionals = cmd_details.get("positionals", [])

        # Check if this is a command group
        from pieces.base_command import CommandGroup

        is_command_group = any(
            isinstance(cmd_class, CommandGroup) and cmd_class.name == cmd_name
            for cmd_class in BaseCommand.commands
        )

        if is_command_group:
            # Skip command groups here - they're handled in _generate_command_groups
            return ""

        # For Fish, we need to create separate completion lines for each command/alias
        all_names = [cmd_name] + cmd_info.aliases

        for name in all_names:
            # Use the helper function for condition
            condition = f'"__{self.tool_name}_using_command {name}"'

            # Add options for this command/alias
            for opt in options:
                script += self._generate_option_completion(opt, condition)

            # Add positional arguments for this command/alias
            for pos in positionals:
                script += self._generate_positional_completion(pos, condition)

        return script

    def _generate_option_completion(self, opt: OptionInfo, condition: str) -> str:
        """Generate Fish completion for an option."""
        script = ""

        # Skip global options that shouldn't appear in subcommands
        if any(
            flag in ["--version", "-v", "--ignore-onboarding"] for flag in opt.flags
        ):
            return ""

        # Build the completion command
        if opt.is_file_type():
            if opt.short_flag and opt.long_flag:
                script += f"""complete -c {self.tool_name} -n {condition} -s {opt.short_flag} -l {opt.long_flag} -r -F -d "{self.escape_string(opt.help)}"
"""
            elif opt.long_flag:
                script += f"""complete -c {self.tool_name} -n {condition} -l {opt.long_flag} -r -F -d "{self.escape_string(opt.help)}"
"""
        elif opt.choices:
            choices_str = " ".join(str(c) for c in opt.choices)
            if opt.short_flag and opt.long_flag:
                script += f"""complete -c {self.tool_name} -n {condition} -s {opt.short_flag} -l {opt.long_flag} -x -a "{choices_str}" -d "{self.escape_string(opt.help)}"
"""
            elif opt.long_flag:
                script += f"""complete -c {self.tool_name} -n {condition} -l {opt.long_flag} -x -a "{choices_str}" -d "{self.escape_string(opt.help)}"
"""
        elif opt.is_integer_type():
            if opt.short_flag and opt.long_flag:
                script += f"""complete -c {self.tool_name} -n {condition} -s {opt.short_flag} -l {opt.long_flag} -x -a "1 2 3 4 5 6 7 8 9 10" -d "{self.escape_string(opt.help)}"
"""
            elif opt.long_flag:
                script += f"""complete -c {self.tool_name} -n {condition} -l {opt.long_flag} -x -a "1 2 3 4 5 6 7 8 9 10" -d "{self.escape_string(opt.help)}"
"""
        else:
            # Regular option
            if opt.short_flag and opt.long_flag:
                script += f"""complete -c {self.tool_name} -n {condition} -s {opt.short_flag} -l {opt.long_flag} -d "{self.escape_string(opt.help)}"
"""
            elif opt.long_flag:
                script += f"""complete -c {self.tool_name} -n {condition} -l {opt.long_flag} -d "{self.escape_string(opt.help)}"
"""

        return script

    def _generate_positional_completion(
        self, pos: PositionalInfo, condition: str
    ) -> str:
        """Generate Fish completion for a positional argument."""
        script = ""

        # Skip positionals that are actually subcommand placeholders
        if pos.dest in ["command", "mcp", "subcommand"]:
            return ""

        if pos.choices:
            choices_str = " ".join(str(c) for c in pos.choices)
            script += f"""# Positional argument: {pos.dest}
complete -c {self.tool_name} -n {condition} -x -a "{choices_str}" -d "{self.escape_string(pos.help)}"
"""
        elif pos.is_file_type():
            script += f"""# Positional argument: {pos.dest} (file)
complete -c {self.tool_name} -n {condition} -F -d "{self.escape_string(pos.help)}"
"""

        return script

    def _generate_command_groups(self) -> str:
        """Generate completions for command groups."""
        script = "\n# Command groups\n"

        # Import CommandGroup to check instances
        from pieces.base_command import CommandGroup

        for cmd in BaseCommand.commands:
            # cmd = cmd_class()  # Instantiate the command
            if isinstance(cmd, CommandGroup):
                # Generate subcommand completions for this group
                script += f"\n# {cmd.name} subcommands\n"

                # First, add options for the command group itself (like -h/--help)
                # These should be available when typing "pieces mcp -<tab>"
                cmd_details = self.parser.subcommand_details.get(cmd.name, {})
                cmd_options = cmd_details.get("options", [])

                # Generate options for the command group when no subcommand is specified
                condition = f'"__{self.tool_name}_using_command {cmd.name}"'
                for opt in cmd_options:
                    script += self._generate_option_completion(opt, condition)

                # Show subcommands when the main command is entered
                subcommand_names = []
                subcommand_helps = {}

                for sub_name, sub_cmd in cmd.subcommands.items():
                    # Skip aliases
                    if sub_name == sub_cmd.name:
                        subcommand_names.append(sub_name)
                        subcommand_helps[sub_name] = sub_cmd.help

                # Add completion for showing subcommands
                for sub_name in sorted(subcommand_names):
                    help_text = self.escape_string(subcommand_helps[sub_name])
                    script += f'complete -c {self.tool_name} -n "__{self.tool_name}_needs_subcommand {cmd.name}" -a "{sub_name}" -d "{help_text}"\n'

                # Add completions for each subcommand's options
                for sub_name, sub_cmd in cmd.subcommands.items():
                    if sub_name != sub_cmd.name:
                        continue  # Skip aliases

                    # Get subcommand details from parser
                    sub_key = f"{cmd.name}_{sub_name}"
                    sub_details = self.parser.subcommand_details.get(sub_key, {})
                    options = sub_details.get("options", [])
                    positionals = sub_details.get("positionals", [])

                    # Generate options for this subcommand
                    condition = (
                        f'"__{self.tool_name}_using_subcommand {cmd.name} {sub_name}"'
                    )

                    for opt in options:
                        script += self._generate_option_completion(opt, condition)

                    for pos in positionals:
                        script += self._generate_positional_completion(pos, condition)

        return script
