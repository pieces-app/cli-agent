name: Build and Release CLI Agent

on:
  workflow_call:
    inputs:
      deploy:
        type: boolean
        required: true
        default: false
    secrets:
      access_token:
        required: true
      pypi_test_token:
        required: false
      pypi_token:
        required: false
      ssh_private_key:
        required: true
      credentials_json:
        required: false
      apple_app_specific_password:
        required: false
      fastlane_password:
        required: false
      match_password:
        required: false
      chocolatey_api_key:
        required: false
      code_signing_cert:
        required: false
      cert_password:
        required: false
      # New DigiCert Software Trust Manager secrets
      sm_host:
        required: false
      sm_api_key:
        required: false
      sm_client_cert_file_b64:
        required: false
      sm_client_cert_password:
        required: false
      sm_code_signing_cert_sha1_hash:
        required: false
      sm_keypair_alias:
        required: false
      personal_access_token:
        required: false

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ macos-14-large, macos-latest, windows-latest ]
        include:
          - os: macos-14-large
            zipFileName: pieces-cli-mac_x86_64
          - os: macos-latest
            zipFileName: pieces-cli-mac_arm64
          - os: windows-latest
            zipFileName: pieces-cli-win_x86_64
    steps:
      ### Checking out our Repo
      - uses: actions/checkout@v3

      ### Setting up python
      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: 3.11

      ### Getting the version from the git tag or the branch name if there is none
      - name: Get the version
        shell: bash
        id: get_version
        run: echo "VERSION=$(echo $GITHUB_REF | cut -d / -f 3)" >> $GITHUB_OUTPUT

      ### Generating our staging version number if we are not production
      - name: Get staging version
        shell: bash
        id: staging_version
        run: echo "STAGING_VERSION=$(/bin/bash staging_versioning.sh)" >> $GITHUB_OUTPUT
        if: inputs.deploy == false

      ### Install SSH
      - uses: shimataro/ssh-key-action@v2
        with:
          key: "${{ secrets.ssh_private_key }}"
          name: id_rsa
          known_hosts: "github.com"
          if_key_exists: fail

      ### Setting up our fastlane certificates
      - name: Setup Certificates
        run: |-
          cd macos
          bundle install
          bundle exec fastlane setup
        env:
          MATCH_PASSWORD: ${{ secrets.match_password }}
          FASTLANE_PASSWORD: ${{ secrets.fastlane_password }}
        if: runner.os != 'Windows'

      ### Installing our dependencies
      - name: Install dependencies
        run: |
          pip install poetry -U
          poetry install 

      ### Setting the version in the pyproject.toml for unix builds
      - name: Set Version Shell Script (Unix)
        if: runner.os != 'Windows'
        run: |
          if [[ ${{ steps.get_version.outputs.VERSION }} =~ [0-9]+.[0-9]+.[0-9]+$ ]]; then
            echo "This is a tagged build"
            RELEASE_VERSION='${{ steps.get_version.outputs.VERSION }}'
            RELEASE_VERSION="${RELEASE_VERSION#v}"
            poetry version $RELEASE_VERSION
            sed -i "" "s/__version__ = .*/__version__ = '${RELEASE_VERSION}'/" src/pieces/__init__.py
          else
            echo "This is not a tagged build"
            STAGING_VERSION='${{ steps.staging_version.outputs.STAGING_VERSION }}'
            poetry version $STAGING_VERSION
            sed -i "" "s/__version__ = .*/__version__ = '${STAGING_VERSION}'/" src/pieces/__init__.py
          fi
        shell: bash

      ### Setting the version in the pyproject.toml for Windows builds
      - name: Set Version PowerShell Script (Windows)
        if: runner.os == 'Windows'
        run: |
          if ("${{ steps.get_version.outputs.VERSION }}" -match "^\d+\.\d+\.\d+$") {
            Write-Output "This is a tagged build"
            $RELEASE_VERSION = "${{ steps.get_version.outputs.VERSION }}".TrimStart("v")
            poetry version $RELEASE_VERSION
            (Get-Content src\pieces\__init__.py) -replace '__version__ = .+', "__version__ = '$RELEASE_VERSION'" | Set-Content src\pieces\__init__.py
          }
          else {
            Write-Output "This is not a tagged build"
            $STAGING_VERSION = "${{ steps.staging_version.outputs.STAGING_VERSION }}"
            poetry version $STAGING_VERSION
            (Get-Content src\pieces\__init__.py) -replace '__version__ = .+', "__version__ = '$STAGING_VERSION'" | Set-Content src\pieces\__init__.py
          }
        shell: pwsh

      ### Writing our staging version to a file to be pulled in the last step to update our json in the cloud
      - name: Write staging version to file
        shell: bash
        run: echo "${{ steps.staging_version.outputs.STAGING_VERSION }}" > staging_version$GITHUB_RUN_NUMBER.txt
        if: ${{ inputs.deploy == false && inputs.beta == false }}

      - name: Build static completions
        shell: bash
        run: |
          mkdir -p src/pieces/completions
          touch src/pieces/completions/__init__.py
          poetry run pip install -e .

          # Generate each completion script with error checking
          echo "Generating Zsh completions..."
          poetry run python completion_scripts/autocomplete_generator.py --zsh > src/pieces/completions/zsh || {
            echo "Failed to generate Zsh completions"
            exit 1
          }

          echo "Generating Bash completions..."
          poetry run python completion_scripts/autocomplete_generator.py --bash > src/pieces/completions/bash || {
            echo "Failed to generate Bash completions"
            exit 1
          }

          echo "Generating Fish completions..."
          poetry run python completion_scripts/autocomplete_generator.py --fish > src/pieces/completions/fish || {
            echo "Failed to generate Fish completions"
            exit 1
          }

          echo "Generating PowerShell completions..."
          poetry run python completion_scripts/autocomplete_generator.py --powershell > src/pieces/completions/powershell || {
            echo "Failed to generate PowerShell completions"
            exit 1
          }

          # Verify files were created and are non-empty
          for shell in zsh bash fish powershell; do
            if [ \! -s "src/pieces/completions/$shell" ]; then
              echo "Error: Completion file for $shell is empty"
              exit 1
            fi
          done


      ### Building the Library and Wheel files
      - name: Build library
        run: poetry build

      - name: Get virtual environment site-packages path
        if: runner.os == 'Windows'
        id: venv_path
        run: |
          Invoke-Expression (poetry env activate)
          poetry install
          $sitePackagesPath = (python -c "import site; print(site.getsitepackages()[0])").Trim()
          Write-Host "Site-packages path: $sitePackagesPath"
          echo "VENV_SITE_PACKAGES_PATH=$sitePackagesPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        shell: powershell

      ### Build stand-alone step for macOS (keeping codesigning)
      - name: Build stand alone (macOS)
        if: runner.os != 'Windows'
        run: |
          poetry run pyinstaller pieces.spec

      ### Build stand-alone step for Windows (build .exe)
      - name: Build stand alone (Windows)
        if: runner.os == 'Windows'
        run: |
          # Ensure we're in the poetry environment
          poetry install
          # Run PyInstaller through poetry to ensure all dependencies are available
          poetry run pyinstaller pieces.spec --clean
        shell: powershell

      ### Package binary to zip file for macOS
      - name: Mac Binary to Zip File
        if: runner.os != 'Windows'
        run: |
          if [[ ${{ steps.get_version.outputs.VERSION }} =~ [0-9]+.[0-9]+.[0-9]+$ ]]; then
              ditto -c -k --sequesterRsrc "dist/pieces" dist/${{ matrix.zipFileName }}-${{ steps.get_version.outputs.VERSION }}.zip
          else
              ditto -c -k --sequesterRsrc "dist/pieces" dist/${{ matrix.zipFileName }}-${{ steps.staging_version.outputs.STAGING_VERSION }}.zip
          fi

      ### Submission to apple notary
      - name: Submit Zip to apple notary
        if: runner.os != 'Windows'
        run: |
          if [[ ${{ steps.get_version.outputs.VERSION }} =~ [0-9]+.[0-9]+.[0-9]+$ ]]
          then
              xcrun notarytool submit dist/${{ matrix.zipFileName }}-${{ steps.get_version.outputs.VERSION }}.zip --password ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }} --apple-id "development@pieces.app" --team-id "287L9TU9JL" --wait
          else
              xcrun notarytool submit dist/${{ matrix.zipFileName }}-${{ steps.staging_version.outputs.STAGING_VERSION }}.zip --password ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }} --apple-id "development@pieces.app" --team-id "287L9TU9JL" --wait
          fi

      ### Install DigiCert Client tools for code signing
      - name: Install DigiCert Software Trust Manager
        if: runner.os == 'Windows'
        uses: digicert/ssm-code-signing@v1.0.1

      ### Setup DigiCert certificate and environment variables
      - name: Set up DigiCert certificate
        if: runner.os == 'Windows' && inputs.deploy == true
        run: |
          # Create temp directory and decode certificate using PowerShell
          New-Item -ItemType Directory -Force -Path "C:\temp"
          $certBytes = [System.Convert]::FromBase64String("${{ secrets.sm_client_cert_file_b64 }}")
          [System.IO.File]::WriteAllBytes("C:\temp\Certificate_pkcs12.p12", $certBytes)
        shell: pwsh

      ### Set Up Digi Cert Credentials
      - name: Set DigiCert environment variables
        if: runner.os == 'Windows' && inputs.deploy == true
        run: |
          echo "SM_HOST=${{ secrets.sm_host }}" >> "$GITHUB_ENV" 
          echo "SM_API_KEY=${{ secrets.sm_api_key }}" >> "$GITHUB_ENV" 
          echo "SM_CLIENT_CERT_FILE=C:\\temp\\Certificate_pkcs12.p12" >> "$GITHUB_ENV" 
          echo "SM_CLIENT_CERT_PASSWORD=${{ secrets.sm_client_cert_password }}" >> "$GITHUB_ENV"
        shell: bash

      ### Run health check for digicert
      - name: Debug DigiCert setup
        if: runner.os == 'Windows' && inputs.deploy == true
        run: |
          echo "Checking DigiCert setup..."
          echo "SM_HOST: $env:SM_HOST"
          echo "SM_CLIENT_CERT_FILE: $env:SM_CLIENT_CERT_FILE"
          Test-Path $env:SM_CLIENT_CERT_FILE
          smctl healthcheck
        shell: pwsh

      ### Sign the Pieces CLI Binary
      - name: Sign EXE
        if: runner.os == 'Windows' && inputs.deploy == true
        run: |
          # Sign using keypair alias
          smctl sign --keypair-alias "${{ secrets.sm_keypair_alias }}" --input ".\dist\pieces.exe" -v
          
          # Check if signing was successful
          if ($LASTEXITCODE -ne 0) {
              Write-Error "EXE signing failed with exit code $LASTEXITCODE"
              exit $LASTEXITCODE
          }
          
          echo "Pieces EXE signed and copied successfully"
        shell: pwsh

      ### Package binary to zip file for Windows using PowerShell
      - name: Windows Binary to Zip File
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          if ("${{ steps.get_version.outputs.VERSION }}" -match "^\d+\.\d+\.\d+$") {
            Compress-Archive -Path ".\dist\pieces.exe" -DestinationPath ".\dist\${{ matrix.zipFileName }}-${{ steps.get_version.outputs.VERSION }}.zip"
          }
          else {
            Compress-Archive -Path ".\dist\pieces.exe" -DestinationPath ".\dist\${{ matrix.zipFileName }}-${{ steps.staging_version.outputs.STAGING_VERSION }}.zip"
          }

      ### Upload to github artifacts
      - uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.os }}
          path: dist/*

      ### Uploading our staging version text file to be pulled down later
      - uses: actions/upload-artifact@v4
        with:
          name: staging_version-${{ matrix.os }}
          path: "*.txt"
        if: inputs.deploy == false

      - name: Test Windows Executable Basic Commands
        if: runner.os == 'Windows'
        run: |
          Get-ChildItem dist
          Set-Location dist

          Write-Host "--- Testing 'pieces.exe --version' command ---"
          .\pieces.exe --ignore-onboarding --version

          Write-Host "--- Testing 'pieces.exe help' command ---"
          .\pieces.exe --ignore-onboarding help

          Write-Host "`nBasic executable functionality tests passed."
        shell: powershell

  ### Pushing the built packages to GCP and GitHub
  push-build:
    runs-on: ubuntu-latest
    #    if: github.ref == 'refs/heads/main'
    needs:
      - build
    steps:

      ### Pulling down the previously built plugins
      - uses: actions/download-artifact@v4

      ### What is in here??
      - name: List
        run: ls -la

      ### Authenticating with gcloud
      - name: Authenticate with Google cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.credentials_json }}
          project_id: ${{ inputs.project_id }}
          create_credentials_file: true

      ### Setting up gcloud cli
      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v2'

      ### Verifying that we are good to go with gcloud
      - name: 'Use gcloud CLI'
        run: 'gcloud info'

      ### Getting either the git tag or branch name to be set in the json
      - name: Get the version
        id: get_version
        run: echo "VERSION=$(echo $GITHUB_REF | cut -d / -f 3)" >> $GITHUB_OUTPUT

      ### Installing some machine deps
      - name: Install Dependencies
        run: sudo apt-get install jq -y

      ### This big, long if statement handles pushing the builds to the correct location, as well as setting the proper
      ### build info for the json files read by the server
      - name: Upload Artifacts
        run: |
          GITHUB_RUN_NUMBER+="gha"
          if [[ ${{ steps.get_version.outputs.VERSION }} =~ [0-9]+.[0-9]+.[0-9]+ ]]; then
          echo "Git Tag Versioning"
          export CHANNEL=production
          export VERSION=${{ steps.get_version.outputs.VERSION }}
          export BUCKET=app-releases-production
          export production_json="$(curl https://storage.googleapis.com/app-releases-production/pieces_cli/production/latest.json -H "Accept: application/json")"
          export reversed_production_json=$(echo $production_json | jq 'reverse')
          export updated_production_json=$(echo $reversed_production_json | jq --arg number "$GITHUB_RUN_NUMBER" --arg channel "$CHANNEL" --arg branch "${{ steps.get_version.outputs.VERSION }}" --arg tag "$VERSION" --arg sha1 "${{ github.sha }}" '.[length] |= . + {channel: $channel, number: $number, branch: $branch, tag: $tag, sha1: $sha1}')
          echo $updated_production_json | jq 'reverse' > latest.json
          jq -n --arg number "$GITHUB_RUN_NUMBER" --arg channel "$CHANNEL" --arg branch "${{ steps.get_version.outputs.VERSION }}" --arg tag "$VERSION" --arg sha1 "${{ github.sha }}" '{channel: $channel, number: $number, branch: $branch, tag: $tag, sha1: $sha1}' > latest-single.json
          else
          echo "Staging Versioning"
          export CHANNEL=staging
          export VERSION=$(echo "$(set -- */*.txt; echo "$1")" | xargs head -n 1)
          export BUCKET=app-releases-staging
          export staging_json="$(curl https://storage.googleapis.com/app-releases-staging/pieces_cli/staging/latest.json -H "Accept: application/json")"
          export reversed_staging_json=$(echo $staging_json | jq 'reverse')
          export updated_staging_json=$(echo $reversed_staging_json | jq --arg number "$GITHUB_RUN_NUMBER" --arg channel "$CHANNEL" --arg branch "${{ steps.get_version.outputs.VERSION }}" --arg tag "$VERSION" --arg sha1 "${{ github.sha }}" '.[length] |= . + {channel: $channel, number: $number, branch: $branch, tag: $tag, sha1: $sha1}')
          echo $updated_staging_json | jq 'reverse' > latest.json
          jq -n --arg number "$GITHUB_RUN_NUMBER" --arg channel "$CHANNEL" --arg branch "${{ steps.get_version.outputs.VERSION }}" --arg tag "$VERSION" --arg sha1 "${{ github.sha }}" '{channel: $channel, number: $number, branch: $branch, tag: $tag, sha1: $sha1}' > latest-single.json
          fi
          #          gsutil -h "Cache-Control: max-age=0" cp */**.tar.gz gs://$BUCKET/pieces_cli/$GITHUB_RUN_NUMBER/pieces.tar.gz
          #          gsutil -h "Cache-Control: max-age=0" cp */**.whl gs://$BUCKET/pieces_cli/$GITHUB_RUN_NUMBER/pieces.tar.gz.whl
          #          gsutil -h "Cache-Control: max-age=0" cp latest-single.json gs://$BUCKET/pieces_cli/$CHANNEL/latest-single.json
          #          gsutil -h "Cache-Control: max-age=0" cp latest.json gs://$BUCKET/pieces_cli/$CHANNEL/latest.json
          #          gsutil cp -r */**.tar.gz gs://$BUCKET/pieces_cli/release/
          #          gsutil cp -r */**.zip gs://$BUCKET/pieces_cli/release/
          #          gsutil cp -r */**.whl gs://$BUCKET/pieces_cli/release/
          # Upload to winget folder (Windows CLI zip only)
          gsutil cp -r */pieces-cli-win_x86_64-*.zip gs://$BUCKET/pieces_cli/winget/
          echo "releasetag=$VERSION" >> $GITHUB_ENV

      ### Upload to GitHub releases pre-release
      #      - name: Release to GitHub Releases
      #        uses: softprops/action-gh-release@v2
      #        if: inputs.deploy == false
      #        with:
      #          files: |
      #            macos-latest/*.tar.gz
      #            macos-latest/*.whl
      #            */**.zip
      #          fail_on_unmatched_files: false
      #          name: ${{ env.releasetag }}
      #          tag_name: ${{ env.releasetag }}
      #          generate_release_notes: true
      #          prerelease: true

      ### Upload to GitHub releases
      #      - name: Release to GitHub Releases
      #        uses: softprops/action-gh-release@v2
      #        if: inputs.deploy == true
      #        with:
      #          files: |
      #            macos-latest/*.tar.gz
      #            macos-latest/*.whl
      #            */**.zip
      #          fail_on_unmatched_files: false
      #          name: ${{ env.releasetag }}
      #          tag_name: ${{ env.releasetag }}
      #          generate_release_notes: true
      #          prerelease: false

      ### Upload to test Pypi
  #      - name: Upload Packages to PyPi for release
  #        if: inputs.deploy == true
  #        run: |-
  #          mkdir dist
  #          cp macos-latest/*.tar.gz macos-latest/*.whl ./dist/
  #          python3 -m pip install --upgrade twine
  #          python -m twine upload --username "__token__" --password "${{ secrets.pypi_token }}" dist/*

  ### Build and publish Chocolatey package
  chocolatey-package:
    runs-on: windows-latest
    if: github.ref == 'refs/heads/main'
    needs: [ build ]
    permissions:
      contents: read
      packages: write
      actions: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download Windows Artifact
        uses: actions/download-artifact@v4
        with:
          name: windows-latest
          path: dist

      ### Download staging version file if it exists
      - name: Download Staging Version File
        if: inputs.deploy == false
        uses: actions/download-artifact@v4
        with:
          name: staging_version-windows-latest
          path: staging_version_files
        continue-on-error: true

      #      - name: Install Chocolatey Package Builder
      #        run: choco install chocolatey-package-builder -y

      - name: Get the version
        shell: bash
        id: get_version
        run: |
          VERSION=$(echo $GITHUB_REF | cut -d / -f 3)
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "Extracted version from GITHUB_REF ($GITHUB_REF): $VERSION"

      ### Get staging version if not a tagged build
      - name: Get staging version
        shell: bash
        id: staging_version
        run: |
          echo "Checking for staging version files..."
          ls -la staging_version_files/ || echo "staging_version_files directory not found"
          
          # Find any .txt file in the staging_version_files directory
          txtfile=$(find staging_version_files -name "*.txt" -type f | head -1)
          if [[ -n "$txtfile" && -f "$txtfile" ]]; then
            STAGING_VERSION=$(cat "$txtfile")
            echo "STAGING_VERSION=$STAGING_VERSION" >> $GITHUB_OUTPUT
            echo "Found staging version: $STAGING_VERSION from file: $txtfile"
          else
            echo "No staging version file found"
            echo "STAGING_VERSION=" >> $GITHUB_OUTPUT
          fi
        if: inputs.deploy == false

      ### Determine final version to use
      - name: Set Final Version
        shell: pwsh
        id: final_version
        run: |
          $gitVersion = "${{ steps.get_version.outputs.VERSION }}"
          $stagingVersion = "${{ steps.staging_version.outputs.STAGING_VERSION }}"
          
          Write-Output "Git version: '$gitVersion'"
          Write-Output "Staging version: '$stagingVersion'"
          
          # Function to normalize version for Chocolatey
          function Normalize-ChocolateyVersion {
            param([string]$version)
          
            # Remove 'v' prefix if present
            $version = $version.TrimStart("v")
          
            # Check if it's a standard semantic version (x.y.z)
            if ($version -match "^(\d+)\.(\d+)\.(\d+)$") {
              return $version
            }
          
            # Handle versions with pre-release identifiers like .dev1, .alpha1, .beta1, etc.
            if ($version -match "^(\d+)\.(\d+)\.(\d+)\.(.+)$") {
              $major = $matches[1]
              $minor = $matches[2]
              $patch = $matches[3]
              $prerelease = $matches[4]
          
              # Convert to Chocolatey-compatible pre-release format
              # .dev1 -> -dev1, .alpha1 -> -alpha1, etc.
              $normalizedPrerelease = $prerelease -replace '^dev', 'dev' -replace '^alpha', 'alpha' -replace '^beta', 'beta' -replace '^rc', 'rc'
              return "$major.$minor.$patch-$normalizedPrerelease"
            }
          
            # Handle versions with dash-separated pre-release (x.y.z-something)
            if ($version -match "^(\d+)\.(\d+)\.(\d+)-(.+)$") {
              return $version  # Already in correct format
            }
          
            # If none of the above patterns match, try to extract just the numeric parts
            if ($version -match "^(\d+)\.(\d+)\.(\d+)") {
              $major = $matches[1]
              $minor = $matches[2] 
              $patch = $matches[3]
              Write-Output "Warning: Version '$version' doesn't match standard format, using base version $major.$minor.$patch"
              return "$major.$minor.$patch"
            }
          
            # Last resort: return a default version
            Write-Output "Warning: Could not parse version '$version', using fallback"
            return "0.0.1"
          }
          
          if ($gitVersion -match "^\d+\.\d+\.\d+$") {
            # This is a tagged build with clean semantic version
            $finalVersion = $gitVersion.TrimStart("v")
            Write-Output "Using clean tag version: $finalVersion"
          } elseif ($gitVersion -match "^v?(\d+\.\d+\.\d+)") {
            # This is a tagged build but may have pre-release suffix
            $finalVersion = Normalize-ChocolateyVersion $gitVersion
            Write-Output "Using normalized tag version: $finalVersion"
          } elseif (![string]::IsNullOrEmpty($stagingVersion)) {
            # This is a staging build with staging version
            $finalVersion = Normalize-ChocolateyVersion $stagingVersion
            Write-Output "Using normalized staging version: $finalVersion"
          } else {
            # Fallback: create a version based on branch name and timestamp
            $timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
            $branchName = $gitVersion -replace '[^a-zA-Z0-9]', ''
            $finalVersion = "0.0.1-$branchName-$timestamp"
            Write-Output "Using generated fallback version: $finalVersion"
          }
          
          Write-Output "Final normalized version: $finalVersion"
          echo "FINAL_VERSION=$finalVersion" >> $env:GITHUB_OUTPUT

      - name: Get Release Notes
        id: release_notes
        run: |
          $version = "${{ steps.final_version.outputs.FINAL_VERSION }}"
          # For release notes lookup, use the original version without pre-release normalization
          $originalVersion = "${{ steps.get_version.outputs.VERSION }}".TrimStart("v")
          try {
            $response = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/releases/tags/v$originalVersion" -Headers @{
              "Accept" = "application/vnd.github.v3+json"
              "Authorization" = "token ${{ secrets.GITHUB_TOKEN }}"
            }
            $releaseNotes = $response.body
            # Escape any special characters that might break the nuspec XML
            $releaseNotes = [System.Security.SecurityElement]::Escape($releaseNotes)
            echo "RELEASE_NOTES=$releaseNotes" >> $env:GITHUB_OUTPUT
          } catch {
            Write-Output "No release notes found for version $originalVersion"
            echo "RELEASE_NOTES=No release notes available" >> $env:GITHUB_OUTPUT
          }

      - name: Copy Exe to Package
        run: |
          # Find the zip file - use final version to determine which zip to look for
          # But we might need to look for the original version in the filename
          $finalVersion = "${{ steps.final_version.outputs.FINAL_VERSION }}"
          $originalVersion = "${{ steps.get_version.outputs.VERSION }}".TrimStart("v")
          
          # Try multiple patterns to find the zip file
          $zipPatterns = @(
            "pieces-cli-win_x86_64-$finalVersion.zip",
            "pieces-cli-win_x86_64-$originalVersion.zip",
            "pieces-cli-win_x86_64-*.zip"
          )
          
          $zipFile = $null
          foreach ($pattern in $zipPatterns) {
            Write-Output "Looking for zip file with pattern: $pattern"
            $zipFile = Get-ChildItem -Path "dist" -Filter $pattern | Select-Object -First 1
            if ($zipFile) {
              Write-Output "Found zip file: $($zipFile.FullName)"
              break
            }
          }
          
          if (-not $zipFile) {
            throw "No pieces-cli-win_x86_64-*.zip file found in dist directory"
          }
          
          # Copy and extract
          Copy-Item -Path $zipFile.FullName -Destination "choco/tools/pieces-cli.zip" -Force
          
          # Extract the zip (this should create choco/tools/pieces.exe)
          Expand-Archive -Path "choco/tools/pieces-cli.zip" -DestinationPath "choco/tools/temp" -Force
          
          # Move the pieces.exe to the correct location
          if (Test-Path "choco/tools/temp/pieces.exe") {
            # If exe is directly in temp, create pieces directory and move it
            New-Item -ItemType Directory -Path "choco/tools/pieces" -Force
            Move-Item "choco/tools/temp/pieces.exe" "choco/tools/pieces/" -Force
            # Move _internal directory if it exists
            if (Test-Path "choco/tools/temp/_internal") {
              Move-Item "choco/tools/temp/_internal" "choco/tools/pieces/" -Force
            }
          } elseif (Test-Path "choco/tools/temp/pieces") {
            # If pieces directory exists, move it directly
            Move-Item "choco/tools/temp/pieces" "choco/tools/" -Force
          } else {
            throw "pieces.exe not found in extracted zip"
          }
          
          # Clean up
          Remove-Item "choco/tools/pieces-cli.zip" -Force
          Remove-Item "choco/tools/temp" -Recurse -Force -ErrorAction SilentlyContinue
          
          # Verify the final structure
          Write-Output "Final structure:"
          Get-ChildItem "choco/tools/pieces" -Recurse | Select-Object Name, FullName

      - name: Copy LICENSE
        run: |
          Copy-Item -Path "LICENSE" -Destination "choco/tools/LICENSE.txt" -Force
          Write-Output "Copied LICENSE to package"

      - name: Update Package Version
        shell: pwsh
        run: |
          cd choco
          $nuspec = Get-Content pieces-cli.nuspec
          $newVersion = "${{ steps.final_version.outputs.FINAL_VERSION }}"
          
          Write-Output "Updating nuspec with version: $newVersion"
          
          # Validate that the version follows Chocolatey's format
          if (-not ($newVersion -match "^(\d+)\.(\d+)\.(\d+)(-[a-zA-Z0-9\-\.]+)?$")) {
            throw "Version '$newVersion' is not in valid Chocolatey format (x.y.z or x.y.z-prerelease)"
          }
          
          # Update version in nuspec
          $nuspec = $nuspec -replace '<version>.*?</version>', "<version>$newVersion</version>"
          
          # Update release notes with the actual GitHub release notes
          # Should we add the release notes to the nuspec?
          # $releaseNotes = "${{ steps.release_notes.outputs.RELEASE_NOTES }}"
          # $nuspec = $nuspec -replace '<releaseNotes>.*?</releaseNotes>', "<releaseNotes>$releaseNotes</releaseNotes>"
          
          $nuspec | Set-Content pieces-cli.nuspec
          
          Write-Output "Updated nuspec version to $newVersion"
          Write-Output "Nuspec version line:"
          $nuspec | Where-Object { $_ -match '<version>' }

      - name: Build Chocolatey Package
        run: |
          cd choco
          choco pack

      - name: Test Package
        run: |
          Write-Output "Installing pieces-cli package for testing..."
          choco install pieces-cli -s . -y
          
          Write-Output "Testing pieces command availability..."
          if (Get-Command pieces -ErrorAction SilentlyContinue) {
            Write-Output "✓ pieces command is available in PATH"
          } else {
            throw "✗ pieces command not found in PATH"
          }
          
          Write-Output "Testing pieces --version..."
          $versionOutput = pieces --ignore-onboarding --version 2>&1
          Write-Output "Version output: $versionOutput"
          
          if ($LASTEXITCODE -eq 0) {
            Write-Output "✓ pieces --version executed successfully"
          } else {
            throw "✗ pieces --version failed with exit code $LASTEXITCODE"
          }
          
          Write-Output "Testing pieces help..."
          $helpOutput = pieces --ignore-onboarding help 2>&1
          if ($LASTEXITCODE -eq 0) {
            Write-Output "✓ pieces help executed successfully"
          } else {
            Write-Output "⚠ pieces help failed, but continuing..."
          }
          
          Write-Output "Uninstalling test package..."
          choco uninstall pieces-cli -y

      ### Always upload artifacts regardless of deploy status
      - name: Upload Chocolatey Package
        uses: actions/upload-artifact@v4
        with:
          name: chocolatey-package
          path: choco/
          if-no-files-found: error

      ### Publish to ChocolateyMore actions
      - name: Publish to Chocolatey
        if: inputs.deploy == true  # Only publish when deploying
        env:
          CHOCOLATEY_API_KEY: ${{ secrets.chocolatey_api_key }}
        run: |
          cd choco
          if ([string]::IsNullOrEmpty($env:CHOCOLATEY_API_KEY)) {
            throw "CHOCOLATEY_API_KEY secret is not set or is empty"
          }
          
          Write-Output "Setting Chocolatey API key..."
          choco apikey --key $env:CHOCOLATEY_API_KEY --source https://push.chocolatey.org/
          
          if ($LASTEXITCODE -ne 0) {
            throw "Failed to set Chocolatey API key"
          }
          
          Write-Output "Finding .nupkg file to publish..."
          $nupkgFile = Get-ChildItem -Filter "pieces-cli.*.nupkg" | Select-Object -First 1
          
          if (-not $nupkgFile) {
            Write-Output "Available files in current directory:"
            Get-ChildItem | Select-Object Name
            throw "No .nupkg file found matching pattern 'pieces-cli.*.nupkg'"
          }
          
          Write-Output "Found package: $($nupkgFile.Name)"
          Write-Output "Publishing package to Chocolatey..."
          choco push "$($nupkgFile.Name)" --source https://push.chocolatey.org/ --force


  # WinGet portable package submission
  winget-submission:
    # https://github.com/actions/runner-images
    # https://github.com/marketplace/actions/install-winget
    # "The windows-2025 GitHub actions runner image now comes preinstalled with winget."
    # The windows-latest is 2022 we will need 2025 runner to have winget CLI
    runs-on: windows-2025
    needs: [ build, push-build ]
    if: inputs.deploy == true  # Only for production releases
    permissions:
      contents: read
      packages: write
      actions: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get the version
        shell: bash
        id: get_version
        run: |
          VERSION=$(echo $GITHUB_REF | cut -d / -f 3)
          # Remove 'v' prefix if present
          VERSION=${VERSION#v}
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT

      - name: Install WinGet Create
        # https://learn.microsoft.com/en-us/windows/package-manager/winget/install
        # --accept-package-agreements: Used to accept the license agreement, and avoid the prompt.
        # --accept-source-agreements: Used to accept the source license agreement, and avoid the prompt.
        run: winget install Microsoft.WingetCreate `
          --accept-source-agreements `
          --accept-package-agreements

      - name: Test PAT permissions
        env:
          WINGET_TOKEN: ${{ secrets.personal_access_token }}
        run: |
          $headers = @{
            'Authorization' = "token $env:WINGET_TOKEN"
            'Accept' = 'application/vnd.github.v3+json'
          }

          # Test basic API access
          Write-Output "Testing PAT permissions..."
          $userInfo = Invoke-RestMethod -Uri "https://api.github.com/user" -Headers $headers
          Write-Output "Authenticated as: $($userInfo.login)"

          # Test ability to list user repos
          $repos = Invoke-RestMethod -Uri "https://api.github.com/user/repos?per_page=1" -Headers $headers
          Write-Output "Can access user repos: True"

          # Test ability to fork (this will actually create a fork for testing)
          Write-Output "Testing fork creation..."
          try {
            $forkResult = Invoke-RestMethod -Uri "https://api.github.com/repos/microsoft/winget-pkgs/forks" -Method POST -Headers $headers
            Write-Output "Fork test successful: $($forkResult.html_url)"

            # Clean up test fork immediately
            Start-Sleep -Seconds 2
            Invoke-RestMethod -Uri "https://api.github.com/repos/$($userInfo.login)/winget-pkgs" -Method DELETE -Headers $headers
            Write-Output "Test fork cleaned up"
          } catch {
            Write-Output "Fork test failed: $($_.Exception.Message)"
          }

      - name: Sync fork with upstream
        env:
          WINGET_TOKEN: ${{ secrets.personal_access_token }}
        run: |
          # Ensure fork exists and is synced with upstream
          Write-Output "Ensuring fork is created and synced..."
          
          $headers = @{
          'Authorization' = "token $env:WINGET_TOKEN"
          'Accept' = 'application/vnd.github.v3+json'
          }
            $userInfo = Invoke-RestMethod -Uri "https://api.github.com/user" -Headers $headers
            $username = $userInfo.login
          
            # Create the fork (if it doesn't already exist)
            try {
            Invoke-RestMethod -Uri "https://api.github.com/repos/microsoft/winget-pkgs/forks" -Method POST -Headers $headers
            Write-Output "Fork requested successfully"
          } catch {
          Write-Output "Fork may already exist or request failed: $($_.Exception.Message)"
          }
          
          # Wait for fork to be available
            $maxAttempts = 10
            $attempt = 1
            $repoUrl = "https://github.com/$username/winget-pkgs"
            do {
            Write-Output "Checking for fork existence (Attempt $attempt of $maxAttempts)..."
            try {
            Invoke-RestMethod -Uri "https://api.github.com/repos/$username/winget-pkgs" -Headers $headers
            Write-Output "Fork is now available."
            break
          } catch {
            Start-Sleep -Seconds 5
            $attempt++
          }
          } while ($attempt -le $maxAttempts)
          
            if ($attempt -gt $maxAttempts) {
            Write-Error "Timed out waiting for fork to be created."
            exit 1
          }
          
          # Clone and sync fork
            $tempRepoPath = Join-Path $env:TEMP "winget-pkgs-sync"
            Remove-Item $tempRepoPath -Recurse -Force -ErrorAction SilentlyContinue
          
            git clone https://$env:WINGET_TOKEN@github.com/$username/winget-pkgs.git $tempRepoPath
            cd $tempRepoPath
            git remote add upstream https://github.com/microsoft/winget-pkgs.git
            git fetch upstream
            git checkout main
            git merge upstream/main
            git push origin main
          
            cd $env:GITHUB_WORKSPACE

      - name: Create/Update WinGet Manifest
        env:
          WINGET_TOKEN: ${{ secrets.personal_access_token }}
        run: |
          $version = "${{ steps.get_version.outputs.VERSION }}"
          $zipUrl = "https://storage.googleapis.com/app-releases-production/pieces_cli/winget/pieces-cli-win_x86_64-$version.zip"
          
          Write-Output "Creating/updating manifest for version $version"
          Write-Output "Using zip URL: $zipUrl"
          
          # Clean up any existing forks to avoid NonFastForwardException
          Write-Output "Cleaning up existing forks..."
          try {
            $headers = @{
              'Authorization' = "token $env:WINGET_TOKEN"
              'Accept' = 'application/vnd.github.v3+json'
            }
            $userInfo = Invoke-RestMethod -Uri "https://api.github.com/user" -Headers $headers
            $username = $userInfo.login
          
            Write-Output "Checking for existing fork at $username/winget-pkgs"
            try {
              $forkInfo = Invoke-RestMethod -Uri "https://api.github.com/repos/$username/winget-pkgs" -Headers $headers
              Write-Output "Found existing fork, deleting..."
              Invoke-RestMethod -Uri "https://api.github.com/repos/$username/winget-pkgs" -Method DELETE -Headers $headers
              Write-Output "Fork deleted successfully"
              Start-Sleep -Seconds 10
            } catch {
              Write-Output "No existing fork found or error deleting: $($_.Exception.Message)"
            }
          } catch {
            Write-Output "Error in cleanup process: $($_.Exception.Message)"
          }
          
          # Create a temporary directory to run wingetcreate from
          $tempDir = New-TemporaryFile | ForEach-Object { Remove-Item $_; New-Item -ItemType Directory -Path $_ }
          Write-Output "Working from temporary directory: $tempDir"
          
          try {
            Set-Location $tempDir
          
            # Check if this is a new package or update
            try {
              $showResult = wingetcreate show --id "MeshIntelligentTechnologies.PiecesCLI"
              Write-Output "Package exists, updating..."
              wingetcreate update "MeshIntelligentTechnologies.PiecesCLI" --version $version --urls $zipUrl --token $env:WINGET_TOKEN --submit
            } catch {
              Write-Output "Package doesn't exist, creating new manifest..."
              wingetcreate new --id "MeshIntelligentTechnologies.PiecesCLI" --version $version --urls $zipUrl --token $env:WINGET_TOKEN --submit
            }
          
          } finally {
            # Clean up temp directory
            Set-Location $env:GITHUB_WORKSPACE
            Remove-Item $tempDir -Recurse -Force -ErrorAction SilentlyContinue
          }
