# coding: utf-8

"""
    Pieces Isomorphic OpenAPI

    Endpoints for Assets, Formats, Users, Asset, Format, User.

    The version of the OpenAPI document: 1.0
    Contact: tsavo@pieces.app
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from pieces._vendor.pieces_os_client.models.embedded_model_schema import EmbeddedModelSchema
from pieces._vendor.pieces_os_client.models.seeded_pkceadditionalparameters import SeededPKCEADDITIONALPARAMETERS
from typing import Optional, Set
from typing_extensions import Self

class SeededPKCE(BaseModel):
    """
    A model that initialized a PKCE Authentication Flow.
    """ # noqa: E501
    additional_parameters: Optional[SeededPKCEADDITIONALPARAMETERS] = Field(default=None, alias="ADDITIONAL_PARAMETERS")
    audience: Optional[StrictStr] = Field(default=None, description="The unique identifier of the target API you want to access. i.e. https://pieces.us.auth0.com/api/v2/")
    client_id: StrictStr = Field(description="Your application's Client ID.")
    code_challenge: StrictStr = Field(description="Generated challenge from the code_verifier.")
    code_challenge_method: StrictStr = Field(description="Method used to generate the challenge. The PKCE spec defines two methods, S256 and plain, however, Auth0 supports only S256 since the latter is discouraged.")
    domain: Optional[StrictStr] = Field(default=None, description="https://auth.pieces.services/authorize")
    invitation: Optional[StrictStr] = None
    nonce: StrictStr = Field(description="A local key that is held as the comparator to state, thus they should be the same.")
    organization: Optional[StrictStr] = None
    prompt: Optional[StrictStr] = Field(default='UNKNOWN', description=" To initiate a silent authentication request, use prompt=none (see Remarks for more info).")
    redirect_uri: Optional[StrictStr] = Field(default=None, description="http://localhost:8080/authentication/response")
    response_mode: Optional[StrictStr] = 'UNKNOWN'
    response_type: StrictStr = Field(description="Indicates to Auth0 which OAuth 2.0 Flow you want to perform. Use code for Authorization Code Grant (PKCE) Flow.")
    var_schema: Optional[EmbeddedModelSchema] = Field(default=None, alias="schema")
    scope: List[StrictStr] = Field(description="The scopes which you want to request authorization for. These must be separated by a space. You can request any of the standard OpenID Connect (OIDC) scopes about users, such as profile and email, custom claims that must conform to a namespaced format, or any scopes supported by the target API (for example, read:contacts). Include offline_access to get a Refresh Token.")
    screen_hint: Optional[StrictStr] = Field(default='UNKNOWN', description="Provides a hint to Auth0 as to what flow should be displayed. The default behavior is to show a login page but you can override this by passing 'signup' to show the signup page instead.")
    state: StrictStr = Field(description="An opaque value the clients adds to the initial request that Auth0 includes when redirecting the back to the client. This value must be used by the client to prevent CSRF attacks.")
    __properties: ClassVar[List[str]] = ["ADDITIONAL_PARAMETERS", "audience", "client_id", "code_challenge", "code_challenge_method", "domain", "invitation", "nonce", "organization", "prompt", "redirect_uri", "response_mode", "response_type", "schema", "scope", "screen_hint", "state"]

    @field_validator('code_challenge_method')
    def code_challenge_method_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['UNKNOWN', 'S256']):
            raise ValueError("must be one of enum values ('UNKNOWN', 'S256')")
        return value

    @field_validator('prompt')
    def prompt_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNKNOWN', 'login', 'none']):
            raise ValueError("must be one of enum values ('UNKNOWN', 'login', 'none')")
        return value

    @field_validator('response_mode')
    def response_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNKNOWN', 'form_post', 'web_message', 'fragment', 'query']):
            raise ValueError("must be one of enum values ('UNKNOWN', 'form_post', 'web_message', 'fragment', 'query')")
        return value

    @field_validator('response_type')
    def response_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['UNKNOWN', 'code', 'token', 'id_token']):
            raise ValueError("must be one of enum values ('UNKNOWN', 'code', 'token', 'id_token')")
        return value

    @field_validator('scope')
    def scope_validate_enum(cls, value):
        """Validates the enum"""
        for i in value:
            if i not in set(['UNKNOWN', 'offline_access', 'email', 'profile', 'openid']):
                raise ValueError("each list item must be one of ('UNKNOWN', 'offline_access', 'email', 'profile', 'openid')")
        return value

    @field_validator('screen_hint')
    def screen_hint_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['UNKNOWN', 'signup']):
            raise ValueError("must be one of enum values ('UNKNOWN', 'signup')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SeededPKCE from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of additional_parameters
        if self.additional_parameters:
            _dict['ADDITIONAL_PARAMETERS'] = self.additional_parameters.to_dict()
        # override the default output from pydantic by calling `to_dict()` of var_schema
        if self.var_schema:
            _dict['schema'] = self.var_schema.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SeededPKCE from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "ADDITIONAL_PARAMETERS": SeededPKCEADDITIONALPARAMETERS.from_dict(obj["ADDITIONAL_PARAMETERS"]) if obj.get("ADDITIONAL_PARAMETERS") is not None else None,
            "audience": obj.get("audience"),
            "client_id": obj.get("client_id"),
            "code_challenge": obj.get("code_challenge"),
            "code_challenge_method": obj.get("code_challenge_method") if obj.get("code_challenge_method") is not None else 'UNKNOWN',
            "domain": obj.get("domain"),
            "invitation": obj.get("invitation"),
            "nonce": obj.get("nonce"),
            "organization": obj.get("organization"),
            "prompt": obj.get("prompt") if obj.get("prompt") is not None else 'UNKNOWN',
            "redirect_uri": obj.get("redirect_uri"),
            "response_mode": obj.get("response_mode") if obj.get("response_mode") is not None else 'UNKNOWN',
            "response_type": obj.get("response_type") if obj.get("response_type") is not None else 'UNKNOWN',
            "schema": EmbeddedModelSchema.from_dict(obj["schema"]) if obj.get("schema") is not None else None,
            "scope": obj.get("scope"),
            "screen_hint": obj.get("screen_hint") if obj.get("screen_hint") is not None else 'UNKNOWN',
            "state": obj.get("state")
        })
        return _obj


